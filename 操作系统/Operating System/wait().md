# `wait()` and `waitpid()`



## wait()

wait() 系统调用挂起父进程的执行，直到其一个子进程终止。一旦子进程终止，wait() 将返回子进程的 PID，并提供其退出状态。

### 原型:

```c
pid_t wait(int *status);
```

### 参数:

status:      一个指向整数的指针，用于存储子进程的退出状态。
返回值:    如果成功，返回已终止的子进程的 PID； 如果调用进程没有子进程或有错误发生，则返回 -1。

## waitpid()

waitpid() 是 wait() 的扩展，它提供了更多的控制，允许父进程等待特定的子进程或者满足某些条件的子进程。

### 原型:

```c
pid_t waitpid(pid_t pid, int *status, int options);
```

### 参数:

- `pid`：
  - 如果 > 0，则 `waitpid()` 只等待与 `pid` 匹配的子进程。
  - 如果 = 0，则 `waitpid()` 等待与调用进程同一进程组的任意一个子进程。
  - 如果 = -1，则 `waitpid()` 等待任意一个子进程，行为与 `wait()` 类似。
  - 如果 < -1，则 `waitpid()` 等待进程组 ID 为 `pid` 绝对值的任何子进程。
- `status`：同上，用于存储子进程的退出状态。
- `options`：提供额外的选项来控制 `waitpid()` 的行为。常见的选项包括：
  - `WNOHANG`: 使 `waitpid()` 成为非阻塞的，如果没有子进程已经退出，则立即返回 0。
  - `WUNTRACED`: 如果子进程被停止（例如，因为收到 SIGSTOP 信号），并且之前尚未报告，则也返回。

### 返回值:

- 如果成功，返回已终止或被停止的子进程的 PID。
- 如果使用了 WNOHANG 选项并且没有子进程已经退出，则返回 0。
- 如果出现错误或调用进程没有子进程，则返回 -1。
  

### 工作原理

当子进程终止时，内核不立即删除其所有信息。它保留一部分信息（例如退出状态），供父进程查询。在父进程调用 wait() 或 waitpid() 并获得子进程的退出状态后，子进程的这部分信息才会被完全删除。

如果子进程在父进程调用 wait() 或 waitpid() 之前已经终止，则这两个调用将立即返回。

### 使用场景

- 防止僵尸进程：当子进程终止并退出后，但其父进程尚未收集其退出状态，子进程会变成僵尸进程。使用 wait() 或 waitpid() 可以避免这种情况。
- 同步：父进程可能需要等待子进程完成某些任务后再继续执行。这时可以使用 wait() 或 waitpid() 来同步父子进程的执行。