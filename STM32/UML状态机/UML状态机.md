# 1.0 UML状态机

## 2.1   事件-动作范式 的过于简单

一个事件本身不能决定要被执行去反应这个事件的动作。当前上下文最少也是同等重要的。 然而，流行的事件 - 动作范型仅认识到对事件类型的依靠，而把上下文的处理交给主要的很容易退化成 “意大利面条式”代码的特定编程技术。

## 2.2     基本状态机

状态机而可以将系统的行为分解成相对小的块，当前状态的响应仅取决于当前事件类型，不在取决于上下文的事件顺序。这种方法里，“行为的块”被叫做状态。行为的改变（例如，响应任何事件的改变）对应着状态改变，被称为状态转换。

FSM是一个界定对全部行为的约束的很有效的方法。“在一个状态里”意味着系统仅响应全部 被允许事件的一个子集，产生可能响应的一个子集，并直接改变状态到所有可能状态的一个子集。

### 2.2.1       状态

状态能被抽象出所有可能（但不相关）的事件序列并仅 捕捉到相关的事件。状态的概念减少了在代码中分辨 执行上下文的问题，只要测试一个状态变量而不是许多变量，从而排除了大量的条件逻辑运算。

### 2.2.2    状态图

FSM有一个叫状态图 (state diagram) 的图型表达方法。这些图是有向图，节点代表状态，连接线代表状 态转换

![image-20230928145443673](UML状态机.assets/image-20230928145443673.png)

### 2.2.3   扩展状态机

在一个系统中，系统的完整状态是定性和定量的结合。一个变量的改变并不意味着状态的转换。因此： 带有变量补充的状态机被称为**扩展状态机**，扩展状态机可以将  **量变带来质变**  引入状态机中， 例如与倒数计数器相结合：

![image-20230928150151700](UML状态机.assets/image-20230928150151700.png)

### 2.2.4    监护条件（Guard Condition）

监护条件（简称监护）是基于扩展状态变量和事件参数动态评估的布尔表达式。监护条件仅在表达式为真时才允许动作或转换，而在表达式为假时禁止它们，从 而影响一个状态机的行为。在 UML 符号里，监护条件在方括号里出现（如 [key_count == 0] ）。  而滥用监护条件会造成，程序又回归到  `if else`  的意大利面条。

 成为高效率状态机设计者的主要一个挑战是培养一种感觉，知道行为的某些部分将会被捕捉成 “定性”方面（状态），而另外一些部分最好被当做“定量”方面（扩展状态变量）。

> * 一般的，你将主 动寻找机会去捕捉事件历史（什么发生了）作为系统的“状态”，而不是在扩展状态变量中存储这些信息。
> * 但 它不能存储太多的信息（比如很多的击键次数）



### 2.2.5    事件

一个事件是对系统有重大意义的一个在时间和空间上所发生的事情。严格的讲，术语 event指所发生事情的类型而不是发生事情的任何具体的实例。一个事件能有相关联的参数，允许事件实例传达不仅某些感兴趣的事件发生了，而且还有关于发 生事情的量化信息。

* 当事件实例被 接收时并等待处理时它被接收（比如它被放在一个事件队列里）
* 事件实例被派送给状态机，这 里它变成当前事件
* 当状态机结束了对这个事件实例的处理后，它被消耗。



### 2.2.6   动作和转换

当一个事件实例被派送，状态机通过执行动作来响应，比如改变一个变量，执行输入输出，调用一个函 数，产生另一个事件实例。或者变成另一个状态。任何和当前事件关联的参数值对被这个事件直接导致 的所有动作都有效。

从一个状态切换到另一个状态被称为状态转换，引发它的事件被称为触发事件 (triggering  event) ，或简单的被称为触发 (trigger) 。在键盘例子里，如果当 `CapsLock` 键被按下时键盘在 default 状态，键盘将进入到 caps_locked 状态。然而，如果键盘已经在 caps_locked 状态，按下 CapsLock键会引发一个不同的转换—从 caps_locked 到 default 。在这 2 个事例里，按下 `CapsLock`  就是 这个触发事件。

在扩展状态机里，一个转换可以有一个监护条件，这意味着仅当监护条件被评估为真时转换才能 “启动”。



### 2.2.7     运行-到-完成执行模型

所有的状态机体系，包括 UML 状态图，普遍的假设一个状态机在它能开始处理下一个事件前完成对 每个事件的处理。这个执行模型被称为运行 - 到 - 完成，或 RTC。

在 RTC模型里，系统在分散的不可分割的 RTC步骤里处理事件。新到的事件不能中断当前事件 的处理，而且必须被存储（通常是存储在一个事件队列里），直到状态机又变成空闲。这些语义完全避 免了在一个单一的状态机里的任何内部并发问题。 RTC模型也克服了处理和转换相关联的动作时的概 念性问题8，因为状态机在动作过程中没有处于一个明确定义的状态（在 2 个状态之间）。在处理事件时， 系统没有响应（不可观测性），因此在那个时段这种不清楚的状态没有实际的意义。

然而请注意， RTC不意味着状态机必须独占 CPU直到 RTC步骤被完成。可抢占性约束只适用 状态机在忙于处理事件的任务上下文的情况。在一个多任务处理环境里，其他（和繁忙的状态机的任务 上下文无关的）任务也可以运行，可能抢占当前执行的状态机。只要其他状态机互相间不共享变量或其 他资源，就不会有并发性的危险。



## 2.3   UML 对传统FSM方法的扩展

FSM即使在处理适度规模的系统，也倾向于变成不可管理（状态爆炸）。由于已知的状态爆炸的现象，传统 FSM的复杂性增加速度会快过它描叙的反应性系统的复杂性。发 生这种情况的原因是因为传统的状态机体系具有重复性。



### 2.3.1   反应性系统里的行为重用

所有反应性系统似乎用一种相似的方法重用行为。这个模式非常精辟：一个 GUI 系统首先 分派每个事件到应用程序（例如 Windows 调用在应用程序里面的一个特定的函数，而把事件作为一个参 数）。如果没有被应用程序处理，这个事件流回系统。这样就建立了一个层次式的事件处理次序。



### 2.3.2    层次式嵌套状态

状态图对经典 FSM最重要的革新是引入了层次式嵌套状态（这就是为什么状态图也被称为层次式状态机HSM的原因）。 和状态嵌套关联的语义如后所示（见图 2.5(a) ）：如果一个系统在嵌套的状态 s11( 称为子状态 ) 里， 它也（隐含的）在环绕的状态 s1( 称为超状态 ) 里。

这个状态机将试着处理任何在状态 s11 上下文的 事件，概念上它在较低层次。然而，如果状态 s11 没有指示如何去处理这个事件，这个事件不会像在 传统的“平面”状态机里那样被默默的丢弃，相反，它被自动的在超状态 s1的较高层上下文里被处理。

![image-20230928214823761](UML状态机.assets/image-20230928214823761.png)

***复杂状态***：包含其他状态的状态

***简单状态***：没有内部结构的状态

***直接子状态***：一个嵌套的状态当它没有被其他状态包含时

***过渡性嵌套子状态***：一个嵌套的状态当它被其他状态包含时

任何层次式状态机可以被看作为一个 复合状态 的内部结构。每个状态机都有一个 **顶状态**，是每个状态机层次的抽象根。

子状态（嵌套状态）仅需要定义与超状态（包围状态）不同的部分。一个子状态可以容易 的通过忽略公共处理的事件，从而重用它的超状态的公共行为，然后这些公共行为自动的被高层的状态处理。通过这个方法，子状态能共享它们的超状态的全部行为。

> …我们一直被我们每次能领会的事物的数目所限制，但是通过抽象，我们通过增加更大的语义内容来使用大量信息。

复合状态不但隐藏了而且通过强大的重用机制（ `Umltimate Hood` 模式）积极的减少了复杂性。



### 2.3.3     行为继承

状态嵌套允许一个子状态从它的祖先（超状态）继承行为。行为继承可以有效地组织代码并提高代码的重用度。



### 2.3.4      Liskov 替换原则（LSP）

Liskov替换原则可以定义为：**如果S是T的子类型，则在任何使用T的地方都可以用S来替代，而不会导致程序的行为发生变化。**

简单来说，就是子类必须能够完全替代父类，并且保持程序的正确性和稳定性。遵守 LSP 可以让我们建立更好的状态层次并有效利用抽象方法。



### 2.3.5     正交区域





### 2.5      小结

事件驱动型系统编程的主要挑战是确定合适的动作并执行它们去响应某个给定的事件。一般来说，这些 动作由两个因素决定：事件的性质以及当前的上下文（也就是说，系统所牵涉的已过去的事件的序列）。 传统的技术，比如事件 - 动作范型，忽视了上下文并造成代码有很多漏洞，使用不成比例数量的令人 费解的条件逻辑，程序员称它为“意大利面条”代码。

基于状态机的技术能够戏剧化地缩减通过代码的不同路径数目并简化在每个分支点的条件测试。 状态机对事件的处理明确地取决于事件的性质和系统的上下文（状态）。这些状态是“行为的分块”， 这里事件 - 动作范型被局部的应用于每个状态内部。状态的概念是系统历史的非常有用的抽象，能仅捕 捉相关的（并忽略掉全部不相关的）激励的序列。在扩展状态机（带有记忆的状态机）里，状态对应于 系统行为的定性化方面，而扩展状态变量（程序内存）对应于系统行为的定量化方面。 

![image-20231001224955130](UML状态机.assets/image-20231001224955130.png)
