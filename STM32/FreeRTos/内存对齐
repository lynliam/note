# 内存对齐

[【烧脑技术贴】无法回避的字节对齐问题，从八个方向深入探讨(变量对齐，栈对齐，DMA对齐，结构体成对齐，Cache, RTOS双堆栈等) - 硬汉嵌入式论坛 - Powered by Discuz!](https://www.armbbs.cn/forum.php?mod=viewthread&action=printable&tid=109400)

[无法回避的字节对齐问题，从八个方向深入探讨(变量对齐，栈对齐，DMA对齐，结构体成对齐，Cache, RTOS双堆栈等)](https://mp.weixin.qq.com/s?__biz=MzI0OTQwNDQxMw==&mid=2247486065&idx=1&sn=fb986e6104f50082f01d3693e0e2a0fc&chksm=e99344e3dee4cdf523d431b4c61d9047ae420b9e304c2cd916dca53dec1543fcdf019b33e44c&scene=27)

内存对齐，又称为字节对齐，是一个数据类型所能存放的内存地址的属性。这个属性实际上就是内存地址，它需要符合一定的规范。这个规范就是内存地址值必须是2的N次方。当我们说一个数据类型的内存对齐为8时，（或按8字节对齐时），实际上指的是它的内存地址值可以被8整除。

1. 标准类型；自然对齐，对齐属性和类型大小相等，或为整数倍
2. 数组：按照基本数据类型对齐，第一个对齐了后面的自然也就对齐了。 
3. 联合：按其包含的长度最大的数据类型对齐。
4. 结构体：结构体中每个数据类型都要对齐。



对齐方法：

1. \#pragma pack(n) 
2. alignas，指定自定义类型的对齐字节

```c
struct alignas(32) MyStruct
```

3. alignof(xx)，获取自定义类型的对齐字节



字节对齐的含义：4字节对齐的含义就是变量地址对4求余数为0；8字节对齐就是地址对8求余等于0，依次类推：

比如

```c
uint32_t *p;
p=(uint32_t *)0x20000004;    //这个地址是4字节对齐。
```

如果让p去访问0x20000001， 0x20000002，0x20000003这都是不对齐访问。



对于M3和M4而言，可以直接访问非对齐地址（注意芯片要在这个地址有对应的内存空间),  因为M3和M4是支持的，而M0/M0+/M1是不支持的，不支持内核芯片，只要**非对齐访问就会触发硬件异常**

![图片](内存对齐.assets/640.webp)![图片](内存对齐.assets/640-1750945545615-7.webp)



### 全局变量对齐

基本上用户定义的变量是几个字节就是几字节对齐，这个比较好理解。

uint8_t定义变量地址要1字节对齐。
uint16_t定义变量地址要2字节对齐。
uint32_t定义变量地址要4字节对齐。
uint64_t定义变量地址要8字节对齐。

指针变量是4字节对齐。

![图片](内存对齐.assets/640-1750945604222-10.webp)

![图片](内存对齐.assets/640-1750945620898-13.webp)



### **局部变量对齐问题：**

局部变量使用的是栈空间（除了静态局部变量和编译器优化不使用栈，直接用寄存器做变量空间），也就是大家使用在xxxx.S启动文件开辟的stack空间。

在M内核里面，局部变量的对齐问题如果研究起来是最烧脑的，这个涉及到AAPCS规约(Procedure Call Standard for the Arm Architecture,  Arm架构的程序调用标准)。

![图片](内存对齐.assets/640-1750945695858-16.webp)、

栈地址是全程至少保持4字节对齐的，因为M内核的硬件长做了处理，SP最低两个bit，bit0和bit1直接固定为0了。

但是在**程序调用入口处必须满足8字节对齐**，对于C语言，不需要用户去管，编译器都帮我们处理好了，先来个简单的示例压压惊：

![图片](内存对齐.assets/640-1750945740366-19.webp)



### **中断服务程序的栈对齐问题：**

先来看两个图：

![图片](内存对齐.assets/640-1750945986838-22.webp)

![图片](内存对齐.assets/640-1750945986838-23.webp)

通过这两个图我们了解到：M0/M0+/M7的栈地址是固定8字节对齐，M3/M4的栈地址是对齐是可以通过SCB->CCR寄存器编程的为4字节或者8字节对齐。

比如我们设置的8字节对齐，那么中断发生的时候，如果SP指针位置在4字节对齐，那么硬件自动插入4字节来保证8字节对齐，之后就是硬件自动入栈的寄存器开始存入栈中。

另外就是不同的M内核硬件版本，这个地方略有不同，这个大家作为了解即可，早期的内核硬件版本应该没什么人用来做芯片了。
![图片](内存对齐.assets/640-1750945986839-24.webp)

 

### **硬件浮点对齐问题**

如果使用的是带FPU硬件浮点单元的M内核芯片就要注意对齐访问了，**访问单精度浮点数访问一定要4字节对齐，双精度要8字节对齐。**

比如我们使用支持单精度浮点的M4内核芯片，测试代码如下：

![图片](内存对齐.assets/640-1750945986839-25.webp)

MDK直接给你来个不对齐硬件异常：

![图片](内存对齐.assets/640-1750945986839-26.webp)



### **RTOS的任务栈：**

RTOS的任务栈涉及到双栈指针问题，SP（R13寄存器）有两个栈指针，MSP主栈指针和PSP进程栈指针。简单的说，我们在中断服务程序里面都是用的MSP，而任务里面用的PSP。

优势是方便任务和中断栈空间分别管理，了解了这点知识就够了。

RTOS任务栈的关键依然是8字节对齐问题，如果仅仅是满足4字节对齐，就会出现我们前面printf和sprintf浮点数或者64bit数据的错误问题，早年各种RTOS移植案例还不是那么发达的时候（现在问题依旧），经常在这个地方入坑，加上硬件浮点寄存器入栈出栈后更是玩不转了。

比如大家搜索关键词 uCOS printf 或者uCOS 浮点数，一堆的问题，平时不用浮点不知道，一用浮点，各种问题就来了，特别是多任务都使用浮点计算，更是懵。

根本原因是底层移植文件的堆栈8字对齐有问题，很多人都是采用的指令__align(8)来设置堆栈对齐问题，其实修改底层port文件才是解决问题的根本。

为什么会造成这个问题，根本原因依然是前面AAPCS规约的要求，RTOS的移植都有个汇编的port文件，这个port文件的关键是实现任务切换，任务切换的关键就是进入任务前保证PSP是8字节对齐。

![图片](内存对齐.assets/640-1750945986839-27.webp)



为了支持双精度浮点、ARM EABI 规范、以及 LDRD/STRD 指令



**九、DMA对齐问题：**

DMA对齐指的是源数据地址和目的数据对齐问题。这个问题最容易出错的地方就是网上倒腾SD卡移植FatFS的SDIO DMA方式。

大家网上搜关键词FatFS SDIO DMA，也是一瓢的问题，特别是BMP等格式图片显示的时候，这种问题就来了，因为很难保证每次的读取都是4字节对齐的。

以STM32F4的DMA为例，我们的底层移植无需再单独开一个缓冲做4字节对齐，本质是F4 DMA支持了源地址和目的地址的数据宽度可以不同，但是数据地址必须要跟其数据类型对齐。

比如使用SDIO DMA从SD卡读取数据，我们就可以设置源地址依然是4字节对齐(外设访问要4字节对齐)，而目的地址设置为字节对齐，就可以方便的解决4字节对齐问题。

![图片](内存对齐.assets/640-1750945986839-28.webp)

其实不仅是通用的DMA，像图形加速DMA2D，SDMMC自带的IDMA等都有这种问题。

一直是使用DMA来传输ADC数据，使用规则注入的方式，但前几天配置一个新工程之后，发现数据比原来小了一半。在检查了四个小时之后，终于发现了问题，在此记录分享。



HAL库里的ADC数据目标地址数组时无符号整型32位，也即对应4字节(1字)

因此，在cubemx中的对应DMA传输数据宽度也要选择‘字’与其对应

如果选择了半字，如下：

就会看到数据是16位传输，目标数组是32位，一个数组变量其实代表了两个数据，而数组后半部分全是0：

![图片](内存对齐.assets/640-1750945986839-29.webp)

![图片](内存对齐.assets/640-1750945986839-30.webp)

使用上述异常数据，计算出来的结果当然就是正常数据的一半。当然，如果想避免这种问题，如果没有那么多的通道数据，可以直接使用触发注入的方式去采集，这样简单便捷，就是需要设置触发信号，




**十、配置MPU造成的对齐问题：**

这个问题主要是对于M7内核芯片来说，以STM32H7 TCM以外空间为例：AXI RAM（0x2400 0000），
SRAM1（0x3000 0000），
SRAM2（0x3002 0000），
SRAM3（0x3004 0000），
SRAM4（0x3800 0000），
SDRAM等做非对齐访问都会有硬件异常，而开启Cache就不会有问题。

这个问题的关键就是M7的TRM中这句话：

意思是，如果用户使用MPU将H7的AXI总线下的内存空间配置为 Device 或者 Strongly-ordered模式，用户采用非对齐方式访问，将会触发UsageFault

![图片](内存对齐.assets/640-1750945986839-31.webp)

实际测序下，果然会触发这个异常

![图片](内存对齐.assets/640-1750945986839-32.webp)

配置内存空间的MPU属性为Device 和 Strongly-ordered以外的属性就可以解决此问题了。



出现alignment fault问题，通常是用户编写的代码导致。估计很多程序猿在编写代码(特别是c/c++代码)时，从未考虑过这样的问题，那是因为多数可能都在X86架构下的进行代码开发，而且没有考虑过代码的移植性，如前面所说X86硬件会自动处理非对齐问题，用户感知不到，但这种情况下，由此带来的性能损耗，用户可能也关注不到了。另一方面，部分情况下，编译器也会自动做padding处理(如对结构体的自动填充对齐)，这也进一步让程序猿们减少了对alignment fault的关注。

　　最常见的可能导致alignment fault的代码编写方式如：

　　1） 指针转换

　　将低位宽类型的指针转换为高位宽类型的指针，如：将char * 转为int *，或将void *转为结构体指针。这类操作是导致alignment fault的最主要的来源，在分析定位问题时，需要特别关注。对于出现异常却又必须这样使用的场景，对这类转换后的指针进行访问时，如果不能确认其对应的地址是对齐的，则应该使用memcpy访问(memcpy方式不存在对齐问题)。另外，建议转换后立即使用，不要将其传递到其他函数和模块，防止扩展，带来潜在的问题。

　　2） 使用packed属性或者编译选项

　　这样的操作会关闭编译器的自动填充功能，从而使结构体中各个字段紧凑排列，如果排列时未处理好对齐，则可能导致alignment fault。一些场景下(内核中也较常见)确实需要用户自行紧凑排列结构体，可节省空间(在内存资源稀缺的场景下，很有用)，此时需要特别关注对齐问题，建议通过填充的方法尽量对齐，如此可能会导致空间浪费，但是会提升访问性能，典型的“以空间换时间”的思路。如果对空间有强烈要求，而可以接受性能损失，也可以不考虑对齐，不做padding，但在访问这些结构体的数据时，需要全部使用memcpy的方式。