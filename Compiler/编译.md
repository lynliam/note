# 编译原理

## 语言处理器

- 编译器：将某种语言翻译成另一种语言
- 解释器：直接利用输入的源程序中指定的操作，逐行执行程序

<img src="编译.assets/image-20230916233448971.png" alt="image-20230916233448971" style="zoom:50%;" />



1. 预编译：
   - 宏定义指令展开
   - 条件编译指令处理
   - 其他宏指令 例如 `#pragma` `#error`
   - 注释处理
   - `#include`头文件递归展开
2. 编译
   - 词法分析：词法分析器读入构成源程序的字符流，组织成有意义的词素，产生语法单元`<token-name, attribute-value>`，<抽象符号，符号表中的条目>
   - 语法分析：将输入的单词组合成正确的语法短语，生成语法树，语法结构
     - `syntax error`
   - 语义分析：使用**语法树** 和 **符号表** 信息来检查源程序是否和语言定义语义一致，例如进行类型检查、变量声明检查
   - 生成中间代码，进行优化
   - 生成汇编代码
3. 汇编
   - 将汇编代码转换为二进制机器码，根据不同的处理器调用不同的指令集，将其转换为机器码（可重定向目标文件）
4. 链接
   - 解决多文件之间符号引用的问题，编译时编译器只对单个文件进行编译，如果某个文件中引用了另一个文件中的函数，此时符号地址无法确定，只有链接器负责将所有目标文件链接在一起，替换掉原来的符号地址，才能生成最终可执行文件。

代码优化阶段：代码优化步骤试图改进中间代码，以便生成更好的目标代码。（自动类型转换）



通过编译生成 **可重定位目标文件**，都是以 零地址为链接起始地址进行链接，每个可重定位目标文件中的函数和变量地址都是相对于零地址的位置偏移。

> 重定位：重新修改各个目标文件中的变量或函数地址。



重定位表：记录需要重定位的函数或变量

符号表：记录源程序中使用的变量的名字，属性，例如 类型、作用域

- 目标文件中引用的全局变量和函数
- 目标文件中定义的全局变量和函数





<img src="https://pica.zhimg.com/v2-cffc83e4ad23320293d8b22050396472_1440w.jpg" alt="img" style="zoom:80%;" />

- [ELF头](https://zhida.zhihu.com/search?content_id=125071314&content_type=Article&match_order=1&q=ELF头&zhida_source=entity)：文件类型、机器类型、节头表的表项大小以及表项个数。
- [.text节](https://zhida.zhihu.com/search?content_id=125071314&content_type=Article&match_order=1&q=.text节&zhida_source=entity)：编译后的汇编代码
- [.rodata节](https://zhida.zhihu.com/search?content_id=125071314&content_type=Article&match_order=1&q=.rodata节&zhida_source=entity)：只读数据，如printf格式串、switch跳转表等。
- [.data节](https://zhida.zhihu.com/search?content_id=125071314&content_type=Article&match_order=1&q=.data节&zhida_source=entity)：已初始化的全局变量，局部静态变量。
- [.bss节](https://zhida.zhihu.com/search?content_id=125071314&content_type=Article&match_order=1&q=.bss节&zhida_source=entity)：未初始化的全局变量，局部静态变量。仅是占位符，不占据任务实际磁盘空间。
- [.symtab节](https://zhida.zhihu.com/search?content_id=125071314&content_type=Article&match_order=1&q=.symtab节&zhida_source=entity)：符号表，存放函数名和全局变量信息（不包括局部变量）。
- [.rel.text节](https://zhida.zhihu.com/search?content_id=125071314&content_type=Article&match_order=1&q=.rel.text节&zhida_source=entity)：代码段的重定位信息
- [.rel.data节](https://zhida.zhihu.com/search?content_id=125071314&content_type=Article&match_order=1&q=.rel.data节&zhida_source=entity)：数据段的重定位信息
- [.debug节](https://zhida.zhihu.com/search?content_id=125071314&content_type=Article&match_order=1&q=.debug节&zhida_source=entity)：调试用的符号表
- .strtab节：包含symtab和debug节中符号及节名。？
- .line节：？
- Section Header table(节头表)：每个节的节名、偏移和大小



<img src="https://pic1.zhimg.com/v2-c11c0391be4d805af239524de36b01a8_1440w.jpg" alt="img" style="zoom:67%;" />

## 符号解析

符号解析是指**确定每个符号的地址**的过程。链接器会检查所有输入的目标文件和库文件，找到每个未解析的符号（undefined symbol）的定义位置，并将其与对应的机器代码或数据地址关联起来。

- 未定义符号
- 多重定义符号
- 外部符号

对局部符号的解析，符号(引用)解析相当明了，同时编译器只要确保它们拥有唯一名称即可

对全局符号和外部符号的引用解析就复杂得多。当编译器遇到一个不是在当前模块中定义的符号(变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条(通常很难阅读的）错误信息并终止。

在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。在扫描中，链接器维护三个集合，初始时三个集合均为空：

- 可重定位目标文件的集合E(Executable)(这个集合中的文件会被合并起来形成可执行文件)；
- 未解析的符号集合U(Unresolved)(即引用了但尚未定义的符号)；
- 已定义的符号集合D(Defined)(在前面输入文件已定义的符号)；
  

## 符号决议

函数和已初始化的全局变量是强符号；未初始化的全局变量是弱符号。

- 规则1: 不允许有多个同名的强符号，若有则报错；
- 规则2: 如果有一个强符号和多个弱符号同名，那么选择强符号；
- 规则3: 如果有多个弱符号同名，那么从这些弱符号中任意选择一个。

## 库

### 静态库链接：

<img src="https://i-blog.csdnimg.cn/blog_migrate/445f4b406dfb15d8edbae3218489f778.png" alt="img" style="zoom:50%;" />

当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序**引用的目标模块**。静态库提出以解决 *让编译器认出对函数的调用造成的符号解析复杂的问题* 和 *将所有标准C函数放在单独可重定位目标模块再引入造成的内存空间浪费的问题*。

在静态链接下，链接器通过将各个目标文件的代码段和数据段合并拷贝到可执行文件，因此静态链接下可执行文件当中包含了所依赖的所有代码和数据

#### 动态链接库：

动态库允许使用该库的可执行文件仅仅包含对动态库的引用而无需将该库拷贝到可执行文件当中。

- 加载时动态链接
- 运行时动态链接

加载时动态链接：

1. 在编译链接生成可执行文件时，需要将使用的动态库加入到链接选项当中，保存动态库信息
2. 依据动态库信息进行动态链接（动态库链接推迟到了程序启动时加载）

运行时动态链接：

1. 通过系统API来调用动态库，可执行文件对动态库信息一无所知
2. （动态库链接推迟到了程序运行时加载）



## 重定位

编译器和汇编器生成从地址0开始的代码和数据节(虚拟内存屏蔽掉物理内存)。**重定位是把每个符号定义与一个内存位置关联起来，进而修改所有对这些符号的引用，使得它们指向这个内存位置**。链接器使用汇编器产生的重定位条目(relocation entry)的详细指令，不加甄别地执行这样的重定位。

①重定位节和符号定义：在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。
 例如，来自所有输入模块的.data 节被全部合并成一个节，这个节成为输出的可执行目标文件的.data 节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了；
②重定位节中的符号引用：在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目的数据结构，上文已描述这种数据结构。



链接器会将所有的**目标文件进行合并**，所有目标文件的数据段合并到可执行文件的数据段，所有目标文件的代码段合并到可执行文件的代码段。当所有合并完成后，各个目标文件中的相对地址也就确定了。因此在这个阶段，链接器需要修正目标文件中的相对地址。

